import csv

# All possible words, it should eventually be reduced to a list of length 1, which should be the word that is the answer
possible_words = []

# All original possible words
all_words = []

# All possible inputs
all_inputs = []

def fetchWords(file_path):
    """
    Loads all words from a CSV file into the global 'all_words' and 'possible_words' lists.
    
    Reads the file, assumes each word is in a new row, and populates both lists with these entries.
    """
    global all_words, possible_words, all_inputs

    with open(file_path, mode='r', newline='') as file:
        csv_reader = csv.reader(file)
        all_words = [row[0] for row in csv_reader]
        possible_words = all_words.copy()
    
    with open("all-inputs.csv", mode='r', newline='') as file:
        csv_reader = csv.reader(file)
        all_inputs = [row[0] for row in csv_reader]

def fetchData(localWords):
    """
    Analyzes letter statistics for a given list of words.
    
    Args:
        localWords (list[str]): List of words to analyze.
    
    Returns:
        dict: A dictionary containing:
            - 'occurrences': Count of words containing each letter.
            - 'frequencies': Total occurrences of each letter across all positions.
            - 'positions': Positional frequency of each letter.
    """
    alphabet = "abcdefghijklmnopqrstuvwxyz"

    occurrences = {letter: 0 for letter in alphabet}
    frequencies = {letter: 0 for letter in alphabet}
    positions = {letter: [0] * 5 for letter in alphabet}

    for word in localWords:
        searched_letters = []
        for index, letter in enumerate(word):
            if letter in alphabet:
                frequencies[letter] += 1
                positions[letter][index] += 1
                if letter not in searched_letters:
                    occurrences[letter] += 1
                    searched_letters.append(letter)

    return {
        "occurrences": occurrences,
        "frequencies": frequencies,
        "positions": positions
    }

def letterCount(word, letter):
    """
    Counts the number of occurrences of a specific letter in a word. Used for filterWords method.
    
    Args:
        word (str): The word to search.
        letter (str): The letter to count.
    
    Returns:
        int: Number of times the letter appears in the word.
    """
    return word.count(letter)

def filterWords(word, positionValues):
    """
    Filters the global 'possible_words' list based on the provided word and positional hints.
    
    Args:
        word (str): The word used for filtering.
        positionValues (list[int]): List of positional hints (length 5):
            - 0: The letter is not in the answer.
            - 1: The letter is in the answer but not in the correct position.
            - 2: The letter is in the correct position.
    """
    global possible_words

    for i in range(5):
        letter = word[i]
        if positionValues[i] == 0:
            # Grey Square - Exclude words containing the letter
            # Only exclude if the letter is not present in other positions with value 1 or 2
            if letter not in [word[j] for j in range(5) if positionValues[j] in (1, 2)]:
                possible_words = list(filter(lambda current_word: letter not in current_word, possible_words))
        elif positionValues[i] == 1:
            # Yellow Square - Include words with the letter but not at the specific position
            possible_words = list(filter(
                lambda current_word: (
                    letter in current_word and
                    letter != current_word[i]
                ),
                possible_words
            ))
        elif positionValues[i] == 2:
            # Green Square - Include words with the letter at the specific position
            possible_words = list(filter(lambda current_word: letter == current_word[i], possible_words))

    # Additional filtering to handle multiple occurrences of the same letter
    for letter in set(word):
        # Count the number of times the letter appears in the word with position values 1 or 2
        required_count = sum(1 for i in range(5) if word[i] == letter and positionValues[i] in (1, 2))
        if required_count > 0:
            possible_words = list(filter(
                lambda current_word: current_word.count(letter) >= required_count,
                possible_words
            ))

def wordScore(word, data):
    """
    Calculates a score for a word based on letter occurrences.
    
    Args:
        word (str): The word to score.
        data (dict): The letter statistics generated by 'fetchData'.
    
    Returns:
        list: A tuple [word, score], where the score is the sum of
              unique letter occurrences in the word.
    """
    score = 0
    lettersChecked = []
    for letter in word:
        if letter not in lettersChecked:
            score += data["occurrences"][letter]
            lettersChecked.append(letter)
    return [word, score]

def bestNextWords(numWords, data):
    scored_words = [wordScore(word, data) for word in possible_words]
    scored_words.sort(key = lambda x: x[1], reverse=True)
    bestWords = scored_words[:numWords]
    return bestWords

def findFillerWords(letters):
    """
    Finds words that contain all specified letters.
    
    Args:
        letters (str): A string of letters to search for.
    
    Returns:
        list: A list of words from 'all_words' that contain all the specified letters.
    
    Example:
        letters = "abc"
        Returns all words that contain 'a', 'b', and 'c'.
    """
    # Filter words that contain all letters
    fillers = [word for word in all_inputs if all(letter in word for letter in letters)]
    return fillers

def validInput(input):
    """
    Returns True if input is a word in all_inputs and if the word is 'filler'
    Returns False if input is not found in all_inputs

    Args:
        input (str): Represents what the user inputted as their word
    
    Returns:
        bool: True if input is a valid word and False if input is not a valid word
    """
    if input == 'filler': return True
    if input in all_inputs: return True
    return False

# Console program
def main():
    """
    Interactive Wordle helper tool.
    - Displays total possible words and top guesses at the start.
    - Allows input of position values without spaces (e.g., '12000').
    - Allows users to type 'filler' to find filler words.
    - Ends when only one possible word remains.
    """

    # Fetch all words from file
    fetchWords('all-answers.csv')
    print(f"Total words fetched: {len(possible_words)}")

    # Get initial data
    data = fetchData(possible_words)
    print("\nTop 10 starting guesses:")
    startingGuesses = bestNextWords(10, data)
    for i in range(10):
        print(f"{i + 1}. {startingGuesses[i][0]} (Score: {startingGuesses[i][1]})")
    
    # Game loop
    while len(possible_words) > 1:
        print(f"\nPossible words remaining: {len(possible_words)}")
        user_word = input("Enter your word (or type 'filler' to find filler words): ").strip().lower()

        while validInput(user_word) == False:
            print(f"\nInvalid Word: {user_word}. Try Again!")
            user_word = input("Enter your word (or type 'filler' to find filler words): ").strip().lower()

        if user_word == "filler":
            letters = input("Enter letters to search for filler words: ").strip().lower()
            filler_words = findFillerWords(letters)
            print("\nFiller words:")
            print(", ".join(filler_words))
            continue

        position_values = list(map(int, list(input("Enter the position values (e.g., 12000): ").strip())))

        # Filter words based on user input
        filterWords(user_word, position_values)

        if len(possible_words) == 1:
            print(f"\nThe answer is: {possible_words[0]}")
        else:
            # Update data for remaining words
            data = fetchData(possible_words)
            print(f"\nTop 10 possible words:")
            nextWords = bestNextWords(10, data)
            for i in range(len(nextWords)):
                print(f"{i + 1}. {nextWords[i][0]} (Score: {nextWords[i][1]})")
            print(f"\nBest next word: {nextWords[0][0]}")

if __name__ == "__main__":
    main()
